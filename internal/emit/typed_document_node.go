package emit

import (
	"context"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
)

// TypedDocumentNodePlugin generates TypedDocumentNode exports for GraphQL operations
type TypedDocumentNodePlugin struct{}

// NewTypedDocumentNodePlugin creates a new TypedDocumentNode plugin
func NewTypedDocumentNodePlugin() plugin.Plugin {
	return &TypedDocumentNodePlugin{}
}

// Name returns the plugin name
func (p *TypedDocumentNodePlugin) Name() string {
	return "typed-document-node"
}

// Description returns the plugin description
func (p *TypedDocumentNodePlugin) Description() string {
	return "Generates TypedDocumentNode exports for GraphQL operations"
}

// Generate generates TypedDocumentNode exports
func (p *TypedDocumentNodePlugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Import TypedDocumentNode
	sb.WriteString("import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n")
	sb.WriteString("import { print } from 'graphql';\n")
	sb.WriteString("import gql from 'graphql-tag';\n\n")

	// Import types (assuming they're generated in the same directory)
	hasOperations := false
	for _, doc := range req.Documents {
		if len(doc.Operations) > 0 {
			hasOperations = true
			break
		}
	}

	if hasOperations {
		sb.WriteString("import type {\n")

		// Collect all operations for import
		var operations []*documents.Operation
		for _, doc := range req.Documents {
			operations = append(operations, doc.Operations...)
		}

		// Sort operations by name
		sort.Slice(operations, func(i, j int) bool {
			return operations[i].Name < operations[j].Name
		})

		// Generate imports
		for _, op := range operations {
			if op.Name == "" {
				continue
			}
			sb.WriteString("  ")
			sb.WriteString(op.Name)
			sb.WriteString("Result,\n")
			sb.WriteString("  ")
			sb.WriteString(op.Name)
			sb.WriteString("Variables,\n")
		}

		sb.WriteString("} from './types';\n\n")
	}

	// Generate fragments first (if any)
	var allFragments []*documents.Fragment
	for _, doc := range req.Documents {
		allFragments = append(allFragments, doc.Fragments...)
	}

	if len(allFragments) > 0 {
		sb.WriteString("// Fragment definitions\n")
		p.generateFragments(&sb, allFragments)
		sb.WriteString("\n")
	}

	// Generate operations
	if hasOperations {
		sb.WriteString("// Operation definitions\n")
		p.generateOperations(&sb, req.Documents)
	}

	// Return the generated code
	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			"operations.ts": []byte(sb.String()),
		},
	}, nil
}

// DefaultConfig returns the default configuration
func (p *TypedDocumentNodePlugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"documentMode":     "TypedDocumentNode", // or "string" for just the query strings
		"dedupeFragments":  true,
		"flattenGeneratedTypes": false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *TypedDocumentNodePlugin) ValidateConfig(config map[string]interface{}) error {
	// Configuration is optional, so always valid
	return nil
}

// generateFragments generates fragment definitions
func (p *TypedDocumentNodePlugin) generateFragments(sb *strings.Builder, fragments []*documents.Fragment) {
	// Sort fragments by name for consistent output
	sort.Slice(fragments, func(i, j int) bool {
		return fragments[i].Name < fragments[j].Name
	})

	for _, frag := range fragments {
		// Generate fragment constant
		sb.WriteString("export const ")
		sb.WriteString(frag.Name)
		sb.WriteString("Fragment = gql`\n")
		sb.WriteString("  fragment ")
		sb.WriteString(frag.Name)
		sb.WriteString(" on ")
		sb.WriteString(frag.TypeCondition)
		sb.WriteString(" {\n")
		sb.WriteString("    # Fragment fields would go here\n")
		sb.WriteString("    __typename\n")
		sb.WriteString("  }\n")
		sb.WriteString("`;\n\n")
	}
}

// generateOperations generates operation definitions
func (p *TypedDocumentNodePlugin) generateOperations(sb *strings.Builder, docs []*documents.Document) {
	// Collect all operations
	type operationWithSource struct {
		op     *documents.Operation
		source string
	}

	var operations []operationWithSource

	for _, doc := range docs {
		for _, op := range doc.Operations {
			operations = append(operations, operationWithSource{
				op:     op,
				source: doc.Content,
			})
		}
	}

	// Sort operations by name for consistent output
	sort.Slice(operations, func(i, j int) bool {
		return operations[i].op.Name < operations[j].op.Name
	})

	// Generate TypedDocumentNode for each operation
	for _, item := range operations {
		op := item.op
		if op.Name == "" {
			continue // Skip anonymous operations
		}

		// Generate the GraphQL document string
		sb.WriteString("const ")
		sb.WriteString(op.Name)
		sb.WriteString("Document = gql`\n")

		// Try to extract the operation from source if available
		if item.source != "" && strings.Contains(item.source, op.Name) {
			// Find and include the actual operation text
			sb.WriteString(indentString(extractOperationText(item.source, op.Name), "  "))
		} else {
			// Fallback: generate a placeholder
			sb.WriteString("  ")
			sb.WriteString(string(op.Type))
			sb.WriteString(" ")
			sb.WriteString(op.Name)

			if len(op.Variables) > 0 {
				sb.WriteString("(")
				for i, v := range op.Variables {
					if i > 0 {
						sb.WriteString(", ")
					}
					sb.WriteString("$")
					sb.WriteString(v.Name)
					sb.WriteString(": ")
					sb.WriteString(v.Type)
				}
				sb.WriteString(")")
			}

			sb.WriteString(" {\n")
			sb.WriteString("    # Operation selection set would go here\n")
			sb.WriteString("  }")
		}

		sb.WriteString("\n`;\n\n")

		// Export as TypedDocumentNode
		sb.WriteString("export const ")
		sb.WriteString(op.Name)
		sb.WriteString(": TypedDocumentNode<")
		sb.WriteString(op.Name)
		sb.WriteString("Result, ")
		sb.WriteString(op.Name)
		sb.WriteString("Variables> = ")
		sb.WriteString(op.Name)
		sb.WriteString("Document;\n\n")
	}
}

// extractOperationText attempts to extract the operation text from source
func extractOperationText(source, operationName string) string {
	// Find the operation in the source
	index := strings.Index(source, operationName)
	if index == -1 {
		return "# Operation not found in source"
	}

	// Try to find the start of the operation (query/mutation/subscription keyword)
	start := index
	for i := index - 1; i >= 0; i-- {
		if strings.HasPrefix(source[i:], "query") ||
			strings.HasPrefix(source[i:], "mutation") ||
			strings.HasPrefix(source[i:], "subscription") ||
			strings.HasPrefix(source[i:], "fragment") {
			start = i
			break
		}
	}

	// Find the matching closing brace
	braceCount := 0
	inString := false
	end := start

	for i := start; i < len(source); i++ {
		ch := source[i]

		// Handle string literals
		if ch == '"' && (i == 0 || source[i-1] != '\\') {
			inString = !inString
		}

		if !inString {
			if ch == '{' {
				braceCount++
			} else if ch == '}' {
				braceCount--
				if braceCount == 0 {
					end = i + 1
					break
				}
			}
		}
	}

	if end > start {
		return strings.TrimSpace(source[start:end])
	}

	return "# Could not extract operation"
}

// indentString adds indentation to each line of a string
func indentString(s, indent string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = indent + line
		}
	}
	return strings.Join(lines, "\n")
}