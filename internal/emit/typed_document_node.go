package emit

import (
	"bytes"
	"context"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/formatter"
)

// TypedDocumentNodePlugin generates TypedDocumentNode exports for GraphQL operations
type TypedDocumentNodePlugin struct{}

// NewTypedDocumentNodePlugin creates a new TypedDocumentNode plugin
func NewTypedDocumentNodePlugin() plugin.Plugin {
	return &TypedDocumentNodePlugin{}
}

// Name returns the plugin name
func (p *TypedDocumentNodePlugin) Name() string {
	return "typed-document-node"
}

// Description returns the plugin description
func (p *TypedDocumentNodePlugin) Description() string {
	return "Generates TypedDocumentNode exports for GraphQL operations"
}

// Generate generates TypedDocumentNode exports
func (p *TypedDocumentNodePlugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Import TypedDocumentNode
	sb.WriteString("import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n")
	sb.WriteString("import { print } from 'graphql';\n")
	sb.WriteString("import gql from 'graphql-tag';\n\n")

	// Collect all operations and fragments
	allOps := documents.CollectAllOperations(req.Documents)
	allFrags := documents.CollectAllFragments(req.Documents)

	hasOperations := len(allOps) > 0

	if hasOperations {
		sb.WriteString("import type {\n")

		// Sort operations by name
		sort.Slice(allOps, func(i, j int) bool {
			return allOps[i].Name < allOps[j].Name
		})

		// Generate imports
		for _, op := range allOps {
			if op.Name == "" {
				continue
			}
			sb.WriteString("  ")
			sb.WriteString(op.Name)
			sb.WriteString("Result,\n")
			sb.WriteString("  ")
			sb.WriteString(op.Name)
			sb.WriteString("Variables,\n")
		}

		sb.WriteString("} from './types';\n\n")
	}

	// Generate fragments first (if any)
	if len(allFrags) > 0 {
		sb.WriteString("// Fragment definitions\n")
		p.generateFragments(&sb, allFrags)
		sb.WriteString("\n")
	}

	// Generate operations
	if hasOperations {
		sb.WriteString("// Operation definitions\n")
		p.generateOperations(&sb, req.Documents)
	}

	// Return the generated code
	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			"operations.ts": []byte(sb.String()),
		},
	}, nil
}

// DefaultConfig returns the default configuration
func (p *TypedDocumentNodePlugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"documentMode":          "TypedDocumentNode",
		"dedupeFragments":       true,
		"flattenGeneratedTypes": false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *TypedDocumentNodePlugin) ValidateConfig(config map[string]interface{}) error {
	// Configuration is optional, so always valid
	return nil
}

// generateFragments generates fragment definitions
func (p *TypedDocumentNodePlugin) generateFragments(sb *strings.Builder, fragments []*ast.FragmentDefinition) {
	// Sort fragments by name for consistent output
	sort.Slice(fragments, func(i, j int) bool {
		return fragments[i].Name < fragments[j].Name
	})

	for _, frag := range fragments {
		// Generate fragment constant
		sb.WriteString("export const ")
		sb.WriteString(frag.Name)
		sb.WriteString("Fragment = gql`\n")

		// Format the fragment using gqlparser's formatter
		var fragBuf bytes.Buffer
		formatter.NewFormatter(&fragBuf).FormatQueryDocument(&ast.QueryDocument{
			Fragments: []*ast.FragmentDefinition{frag},
		})

		// Indent the output
		lines := strings.Split(fragBuf.String(), "\n")
		for _, line := range lines {
			if line != "" {
				sb.WriteString("  ")
				sb.WriteString(line)
				sb.WriteString("\n")
			}
		}

		sb.WriteString("`;\n\n")
	}
}

// generateOperations generates operation definitions
func (p *TypedDocumentNodePlugin) generateOperations(sb *strings.Builder, docs []*documents.Document) {
	// Collect all operations
	allOps := documents.CollectAllOperations(docs)

	// Sort operations by name for consistent output
	sort.Slice(allOps, func(i, j int) bool {
		return allOps[i].Name < allOps[j].Name
	})

	// Generate TypedDocumentNode for each operation
	for _, op := range allOps {
		if op.Name == "" {
			continue // Skip anonymous operations
		}

		// Generate the GraphQL document string
		sb.WriteString("const ")
		sb.WriteString(op.Name)
		sb.WriteString("Document = gql`\n")

		// Format the operation using gqlparser's formatter
		var opBuf bytes.Buffer
		formatter.NewFormatter(&opBuf).FormatQueryDocument(&ast.QueryDocument{
			Operations: []*ast.OperationDefinition{op},
		})

		// Indent the output
		lines := strings.Split(opBuf.String(), "\n")
		for _, line := range lines {
			if line != "" {
				sb.WriteString("  ")
				sb.WriteString(line)
				sb.WriteString("\n")
			}
		}

		sb.WriteString("`;\n\n")

		// Export as TypedDocumentNode
		sb.WriteString("export const ")
		sb.WriteString(op.Name)
		sb.WriteString(": TypedDocumentNode<")
		sb.WriteString(op.Name)
		sb.WriteString("Result, ")
		sb.WriteString(op.Name)
		sb.WriteString("Variables> = ")
		sb.WriteString(op.Name)
		sb.WriteString("Document;\n\n")
	}
}

// Helper function to get operation source with fragments
func getOperationSource(op *ast.OperationDefinition, fragments []*ast.FragmentDefinition) string {
	// Find used fragments
	usedFragments := documents.GetUsedFragments(op.SelectionSet)

	// Build a document with the operation and its fragments
	doc := &ast.QueryDocument{
		Operations: []*ast.OperationDefinition{op},
		Fragments:  make([]*ast.FragmentDefinition, 0),
	}

	for _, fragName := range usedFragments {
		for _, frag := range fragments {
			if frag.Name == fragName {
				doc.Fragments = append(doc.Fragments, frag)
				break
			}
		}
	}

	// Format the complete document
	var buf bytes.Buffer
	formatter.NewFormatter(&buf).FormatQueryDocument(doc)
	return buf.String()
}