package emit

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/vektah/gqlparser/v2/ast"
)

// TypeScriptPlugin generates TypeScript type definitions from GraphQL schema using gqlparser
type TypeScriptPlugin struct{}

// NewTypeScriptPlugin creates a new TypeScript plugin
func NewTypeScriptPlugin() plugin.Plugin {
	return &TypeScriptPlugin{}
}

// Name returns the plugin name
func (p *TypeScriptPlugin) Name() string {
	return "typescript"
}

// Description returns the plugin description
func (p *TypeScriptPlugin) Description() string {
	return "Generates TypeScript type definitions from GraphQL schema"
}

// Generate generates TypeScript types
func (p *TypeScriptPlugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	strictNulls := req.Options.StrictNulls
	enumsAsTypes := req.Options.EnumsAsTypes

	if req.Schema == nil || req.Schema.Raw() == nil {
		return nil, fmt.Errorf("schema is required")
	}

	astSchema := req.Schema.Raw()

	// Generate scalar type mappings
	sb.WriteString("// Scalar type mappings\n")
	p.generateScalarTypes(&sb, astSchema, req.ScalarMap)
	sb.WriteString("\n")

	// Generate enum types
	sb.WriteString("// Enum types\n")
	p.generateEnumTypes(&sb, astSchema, enumsAsTypes)
	sb.WriteString("\n")

	// Generate input types
	sb.WriteString("// Input types\n")
	p.generateInputTypes(&sb, astSchema, strictNulls, req.ScalarMap)
	sb.WriteString("\n")

	// Generate object types
	sb.WriteString("// Object types\n")
	p.generateObjectTypes(&sb, astSchema, strictNulls, req.ScalarMap)
	sb.WriteString("\n")

	// Generate interface types
	sb.WriteString("// Interface types\n")
	p.generateInterfaceTypes(&sb, astSchema, strictNulls, req.ScalarMap)
	sb.WriteString("\n")

	// Generate union types
	sb.WriteString("// Union types\n")
	p.generateUnionTypes(&sb, astSchema)
	sb.WriteString("\n")

	// Generate operation types if we have documents
	if len(req.Documents) > 0 {
		sb.WriteString("// Operation types\n")
		p.generateOperationTypes(&sb, req.Documents, astSchema, strictNulls, req.ScalarMap)
	}

	// Return the generated code
	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			"types.ts": []byte(sb.String()),
		},
	}, nil
}

// DefaultConfig returns the default configuration
func (p *TypeScriptPlugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"strictNulls":    false,
		"enumsAsTypes":   false,
		"immutableTypes": false,
		"namingConvention": map[string]string{
			"typeNames":  "PascalCase",
			"enumValues": "SCREAMING_SNAKE_CASE",
		},
	}
}

// ValidateConfig validates the plugin configuration
func (p *TypeScriptPlugin) ValidateConfig(config map[string]interface{}) error {
	// Configuration is optional, so always valid
	return nil
}

// generateScalarTypes generates TypeScript type aliases for custom scalars
func (p *TypeScriptPlugin) generateScalarTypes(sb *strings.Builder, s *ast.Schema, scalarMap map[string]string) {
	// Default scalar mappings
	defaultScalars := map[string]string{
		"ID":      "string",
		"String":  "string",
		"Int":     "number",
		"Float":   "number",
		"Boolean": "boolean",
	}

	// Collect custom scalars from schema
	var customScalars []string
	for name, def := range s.Types {
		if def.Kind == ast.Scalar && defaultScalars[name] == "" && !strings.HasPrefix(name, "__") {
			customScalars = append(customScalars, name)
		}
	}

	// Sort for consistent output
	sort.Strings(customScalars)

	// Generate type aliases for custom scalars
	for _, name := range customScalars {
		tsType := "any" // Default type
		if mapped, ok := scalarMap[name]; ok {
			tsType = mapped
		}

		sb.WriteString("export type ")
		sb.WriteString(name)
		sb.WriteString(" = ")
		sb.WriteString(tsType)
		sb.WriteString(";\n")
	}
}

// generateEnumTypes generates TypeScript enum types
func (p *TypeScriptPlugin) generateEnumTypes(sb *strings.Builder, s *ast.Schema, enumsAsTypes bool) {
	var enumNames []string

	// Collect all enum types
	for name, def := range s.Types {
		if def.Kind == ast.Enum && !strings.HasPrefix(name, "__") {
			enumNames = append(enumNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(enumNames)

	// Generate enum types
	for _, name := range enumNames {
		def := s.Types[name]

		if enumsAsTypes {
			// Generate as union type
			sb.WriteString("export type ")
			sb.WriteString(name)
			sb.WriteString(" =\n")

			for i, val := range def.EnumValues {
				sb.WriteString("  | '")
				sb.WriteString(val.Name)
				sb.WriteString("'")
				if i < len(def.EnumValues)-1 {
					sb.WriteString("\n")
				}
			}
			sb.WriteString(";\n\n")
		} else {
			// Generate as enum
			sb.WriteString("export enum ")
			sb.WriteString(name)
			sb.WriteString(" {\n")

			for _, val := range def.EnumValues {
				sb.WriteString("  ")
				sb.WriteString(val.Name)
				sb.WriteString(" = '")
				sb.WriteString(val.Name)
				sb.WriteString("',\n")
			}

			sb.WriteString("}\n\n")
		}
	}
}

// generateInputTypes generates TypeScript interfaces for GraphQL input types
func (p *TypeScriptPlugin) generateInputTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, scalarMap map[string]string) {
	var inputNames []string

	// Collect all input types
	for name, def := range s.Types {
		if def.Kind == ast.InputObject && !strings.HasPrefix(name, "__") {
			inputNames = append(inputNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(inputNames)

	// Generate input interfaces
	for _, name := range inputNames {
		def := s.Types[name]

		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")

		for _, field := range def.Fields {
			sb.WriteString("  ")
			sb.WriteString(field.Name)

			// Add optional marker if field is nullable
			if field.Type.NonNull == false && !strictNulls {
				sb.WriteString("?")
			}

			sb.WriteString(": ")
			sb.WriteString(p.typeToTypeScript(field.Type, scalarMap))

			// Add null union if strictNulls and nullable
			if field.Type.NonNull == false && strictNulls {
				sb.WriteString(" | null")
			}

			sb.WriteString(";\n")
		}

		sb.WriteString("}\n\n")
	}
}

// generateObjectTypes generates TypeScript interfaces for GraphQL object types
func (p *TypeScriptPlugin) generateObjectTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, scalarMap map[string]string) {
	var objectNames []string

	// Collect all object types
	for name, def := range s.Types {
		if def.Kind == ast.Object && !strings.HasPrefix(name, "__") {
			objectNames = append(objectNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(objectNames)

	// Generate object interfaces
	for _, name := range objectNames {
		def := s.Types[name]

		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")

		// Add __typename field
		sb.WriteString("  __typename?: '")
		sb.WriteString(name)
		sb.WriteString("';\n")

		// Add fields
		for _, field := range def.Fields {
			sb.WriteString("  ")
			sb.WriteString(field.Name)

			// Add optional marker if field is nullable
			if field.Type.NonNull == false && !strictNulls {
				sb.WriteString("?")
			}

			sb.WriteString(": ")
			sb.WriteString(p.typeToTypeScript(field.Type, scalarMap))

			// Add null union if strictNulls and nullable
			if field.Type.NonNull == false && strictNulls {
				sb.WriteString(" | null")
			}

			sb.WriteString(";\n")
		}

		sb.WriteString("}\n\n")
	}
}

// generateInterfaceTypes generates TypeScript interfaces for GraphQL interfaces
func (p *TypeScriptPlugin) generateInterfaceTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, scalarMap map[string]string) {
	var interfaceNames []string

	// Collect all interface types
	for name, def := range s.Types {
		if def.Kind == ast.Interface && !strings.HasPrefix(name, "__") {
			interfaceNames = append(interfaceNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(interfaceNames)

	// Generate interfaces
	for _, name := range interfaceNames {
		def := s.Types[name]

		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")

		// Add fields
		for _, field := range def.Fields {
			sb.WriteString("  ")
			sb.WriteString(field.Name)

			// Add optional marker if field is nullable
			if field.Type.NonNull == false && !strictNulls {
				sb.WriteString("?")
			}

			sb.WriteString(": ")
			sb.WriteString(p.typeToTypeScript(field.Type, scalarMap))

			// Add null union if strictNulls and nullable
			if field.Type.NonNull == false && strictNulls {
				sb.WriteString(" | null")
			}

			sb.WriteString(";\n")
		}

		sb.WriteString("}\n\n")
	}
}

// generateUnionTypes generates TypeScript union types
func (p *TypeScriptPlugin) generateUnionTypes(sb *strings.Builder, s *ast.Schema) {
	var unionNames []string

	// Collect all union types
	for name, def := range s.Types {
		if def.Kind == ast.Union && !strings.HasPrefix(name, "__") {
			unionNames = append(unionNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(unionNames)

	// Generate union types
	for _, name := range unionNames {
		def := s.Types[name]

		sb.WriteString("export type ")
		sb.WriteString(name)
		sb.WriteString(" =\n")

		for i, typeName := range def.Types {
			sb.WriteString("  | ")
			sb.WriteString(typeName)
			if i < len(def.Types)-1 {
				sb.WriteString("\n")
			}
		}

		sb.WriteString(";\n\n")
	}
}

// generateOperationTypes generates TypeScript types for GraphQL operations
func (p *TypeScriptPlugin) generateOperationTypes(sb *strings.Builder, docs []*documents.Document, s *ast.Schema, strictNulls bool, scalarMap map[string]string) {
	// Collect all operations
	operations := documents.CollectAllOperations(docs)

	// Sort operations by name for consistent output
	sort.Slice(operations, func(i, j int) bool {
		return operations[i].Name < operations[j].Name
	})

	// Generate types for each operation
	for _, op := range operations {
		if op.Name == "" {
			continue // Skip anonymous operations
		}

		// Generate variables type
		sb.WriteString("export interface ")
		sb.WriteString(op.Name)
		sb.WriteString("Variables {\n")

		if len(op.VariableDefinitions) > 0 {
			for _, v := range op.VariableDefinitions {
				sb.WriteString("  ")
				sb.WriteString(v.Variable)

				// Add optional marker if variable is nullable
				if v.Type.NonNull == false && !strictNulls {
					sb.WriteString("?")
				}

				sb.WriteString(": ")
				sb.WriteString(p.typeToTypeScript(v.Type, scalarMap))

				// Add null union if strictNulls and nullable
				if v.Type.NonNull == false && strictNulls {
					sb.WriteString(" | null")
				}

				sb.WriteString(";\n")
			}
		} else {
			sb.WriteString("  // No variables\n")
		}

		sb.WriteString("}\n\n")

		// Generate result type
		sb.WriteString("export interface ")
		sb.WriteString(op.Name)
		sb.WriteString("Result {\n")

		// Generate result fields based on selection set
		p.generateSelectionSetTypes(sb, op.SelectionSet, s, strictNulls, scalarMap, "  ")

		sb.WriteString("}\n\n")
	}
}

// generateSelectionSetTypes generates TypeScript types for a selection set
func (p *TypeScriptPlugin) generateSelectionSetTypes(sb *strings.Builder, selections ast.SelectionSet, s *ast.Schema, strictNulls bool, scalarMap map[string]string, indent string) {
	for _, selection := range selections {
		switch sel := selection.(type) {
		case *ast.Field:
			sb.WriteString(indent)
			sb.WriteString(sel.Alias)

			// Look up the field type
			var fieldType *ast.Type
			if sel.Definition != nil {
				fieldType = sel.Definition.Type
			}

			if fieldType != nil {
				// Add optional marker if field is nullable
				if fieldType.NonNull == false && !strictNulls {
					sb.WriteString("?")
				}

				sb.WriteString(": ")

				// If field has subselections, generate inline interface
				if len(sel.SelectionSet) > 0 {
					sb.WriteString("{\n")
					p.generateSelectionSetTypes(sb, sel.SelectionSet, s, strictNulls, scalarMap, indent+"  ")
					sb.WriteString(indent)
					sb.WriteString("}")
				} else {
					sb.WriteString(p.typeToTypeScript(fieldType, scalarMap))
				}

				// Add null union if strictNulls and nullable
				if fieldType.NonNull == false && strictNulls {
					sb.WriteString(" | null")
				}
			} else {
				// Fallback if we can't determine the type
				sb.WriteString(": any")
			}

			sb.WriteString(";\n")

		case *ast.InlineFragment:
			// Handle inline fragments
			p.generateSelectionSetTypes(sb, sel.SelectionSet, s, strictNulls, scalarMap, indent)

		case *ast.FragmentSpread:
			// Handle fragment spreads - would need fragment definitions
			sb.WriteString(indent)
			sb.WriteString("// Fragment spread: ")
			sb.WriteString(sel.Name)
			sb.WriteString("\n")
		}
	}
}

// typeToTypeScript converts a GraphQL type to TypeScript
func (p *TypeScriptPlugin) typeToTypeScript(t *ast.Type, scalarMap map[string]string) string {
	if t == nil {
		return "any"
	}

	// Handle list types
	if t.Elem != nil {
		elemType := p.typeToTypeScript(t.Elem, scalarMap)
		if t.NonNull {
			return elemType + "[]"
		}
		return elemType + "[] | null"
	}

	// Get the base type name
	baseType := t.Name()

	// Map to TypeScript type
	var tsType string
	switch baseType {
	case "ID", "String":
		tsType = "string"
	case "Int", "Float":
		tsType = "number"
	case "Boolean":
		tsType = "boolean"
	default:
		// Check custom scalar mapping
		if mapped, ok := scalarMap[baseType]; ok {
			tsType = mapped
		} else {
			// Use the type name as-is (for enums, objects, etc.)
			tsType = baseType
		}
	}

	return tsType
}