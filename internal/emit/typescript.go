package emit

import (
	"context"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/schema"
)

// TypeScriptPlugin generates TypeScript type definitions from GraphQL schema
type TypeScriptPlugin struct{}

// NewTypeScriptPlugin creates a new TypeScript plugin
func NewTypeScriptPlugin() plugin.Plugin {
	return &TypeScriptPlugin{}
}

// Name returns the plugin name
func (p *TypeScriptPlugin) Name() string {
	return "typescript"
}

// Description returns the plugin description
func (p *TypeScriptPlugin) Description() string {
	return "Generates TypeScript type definitions from GraphQL schema"
}

// Generate generates TypeScript types
func (p *TypeScriptPlugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	strictNulls := req.Options.StrictNulls
	enumsAsTypes := req.Options.EnumsAsTypes

	// Generate scalar type mappings
	sb.WriteString("// Scalar type mappings\n")
	p.generateScalarTypes(&sb, req.ScalarMap)
	sb.WriteString("\n")

	// Generate enum types
	if req.Schema != nil {
		sb.WriteString("// Enum types\n")
		p.generateEnumTypes(&sb, req.Schema, enumsAsTypes)
		sb.WriteString("\n")

		// Generate input types
		sb.WriteString("// Input types\n")
		p.generateInputTypes(&sb, req.Schema, strictNulls, req.ScalarMap)
		sb.WriteString("\n")

		// Generate object types
		sb.WriteString("// Object types\n")
		p.generateObjectTypes(&sb, req.Schema, strictNulls, req.ScalarMap)
		sb.WriteString("\n")

		// Generate interface types
		sb.WriteString("// Interface types\n")
		p.generateInterfaceTypes(&sb, req.Schema, strictNulls, req.ScalarMap)
		sb.WriteString("\n")

		// Generate union types
		sb.WriteString("// Union types\n")
		p.generateUnionTypes(&sb, req.Schema)
		sb.WriteString("\n")
	}

	// Generate operation types if we have documents
	if len(req.Documents) > 0 {
		sb.WriteString("// Operation types\n")
		p.generateOperationTypes(&sb, req.Documents, req.Schema, strictNulls, req.ScalarMap)
	}

	// Return the generated code
	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			"types.ts": []byte(sb.String()),
		},
	}, nil
}

// DefaultConfig returns the default configuration
func (p *TypeScriptPlugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"strictNulls":    false,
		"enumsAsTypes":   false,
		"immutableTypes": false,
		"namingConvention": map[string]string{
			"typeNames": "PascalCase",
			"enumValues": "SCREAMING_SNAKE_CASE",
		},
	}
}

// ValidateConfig validates the plugin configuration
func (p *TypeScriptPlugin) ValidateConfig(config map[string]interface{}) error {
	// Configuration is optional, so always valid
	return nil
}

// generateScalarTypes generates TypeScript type aliases for custom scalars
func (p *TypeScriptPlugin) generateScalarTypes(sb *strings.Builder, scalarMap map[string]string) {
	// Default scalar mappings
	defaultScalars := map[string]string{
		"ID":      "string",
		"String":  "string",
		"Int":     "number",
		"Float":   "number",
		"Boolean": "boolean",
	}

	// Merge custom scalars with defaults
	allScalars := make(map[string]string)
	for k, v := range defaultScalars {
		allScalars[k] = v
	}
	for k, v := range scalarMap {
		allScalars[k] = v
	}

	// Sort scalar names for consistent output
	var scalarNames []string
	for name := range scalarMap {
		scalarNames = append(scalarNames, name)
	}
	sort.Strings(scalarNames)

	// Generate type aliases for custom scalars only
	for _, name := range scalarNames {
		tsType := allScalars[name]
		sb.WriteString("export type ")
		sb.WriteString(name)
		sb.WriteString(" = ")
		sb.WriteString(tsType)
		sb.WriteString(";\n")
	}
}

// generateEnumTypes generates TypeScript enum types
func (p *TypeScriptPlugin) generateEnumTypes(sb *strings.Builder, s schema.Schema, enumsAsTypes bool) {
	if s == nil {
		return
	}

	typeMap := s.GetTypeMap()
	var enumNames []string

	// Collect all enum types
	for name, t := range typeMap {
		if enum, ok := t.(*schema.Enum); ok {
			enumNames = append(enumNames, name)
			_ = enum // Will be used when we have enum values
		}
	}

	// Sort for consistent output
	sort.Strings(enumNames)

	// Generate enum types
	for _, name := range enumNames {
		if enumsAsTypes {
			// Generate as union type
			sb.WriteString("export type ")
			sb.WriteString(name)
			sb.WriteString(" =\n")
			// TODO: Add enum values when available in schema
			sb.WriteString("  | 'PLACEHOLDER';\n")
		} else {
			// Generate as enum
			sb.WriteString("export enum ")
			sb.WriteString(name)
			sb.WriteString(" {\n")
			// TODO: Add enum values when available in schema
			sb.WriteString("  PLACEHOLDER = 'PLACEHOLDER',\n")
			sb.WriteString("}\n")
		}
		sb.WriteString("\n")
	}
}

// generateInputTypes generates TypeScript interfaces for GraphQL input types
func (p *TypeScriptPlugin) generateInputTypes(sb *strings.Builder, s schema.Schema, strictNulls bool, scalarMap map[string]string) {
	if s == nil {
		return
	}

	typeMap := s.GetTypeMap()
	var inputNames []string

	// Collect all input types
	for name, t := range typeMap {
		if _, ok := t.(*schema.InputObject); ok {
			inputNames = append(inputNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(inputNames)

	// Generate input interfaces
	for _, name := range inputNames {
		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")
		// TODO: Add fields when available in schema
		sb.WriteString("  // TODO: Add input fields\n")
		sb.WriteString("}\n\n")
	}
}

// generateObjectTypes generates TypeScript interfaces for GraphQL object types
func (p *TypeScriptPlugin) generateObjectTypes(sb *strings.Builder, s schema.Schema, strictNulls bool, scalarMap map[string]string) {
	if s == nil {
		return
	}

	typeMap := s.GetTypeMap()
	var objectNames []string

	// Collect all object types (excluding Query, Mutation, Subscription)
	for name, t := range typeMap {
		if _, ok := t.(*schema.Object); ok {
			// Skip internal types
			if strings.HasPrefix(name, "__") {
				continue
			}
			objectNames = append(objectNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(objectNames)

	// Generate object interfaces
	for _, name := range objectNames {
		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")
		// TODO: Add fields when available in schema
		sb.WriteString("  __typename?: '")
		sb.WriteString(name)
		sb.WriteString("';\n")
		sb.WriteString("  // TODO: Add object fields\n")
		sb.WriteString("}\n\n")
	}
}

// generateInterfaceTypes generates TypeScript interfaces for GraphQL interfaces
func (p *TypeScriptPlugin) generateInterfaceTypes(sb *strings.Builder, s schema.Schema, strictNulls bool, scalarMap map[string]string) {
	if s == nil {
		return
	}

	typeMap := s.GetTypeMap()
	var interfaceNames []string

	// Collect all interface types
	for name, t := range typeMap {
		if _, ok := t.(*schema.Interface); ok {
			interfaceNames = append(interfaceNames, name)
		}
	}

	// Sort for consistent output
	sort.Strings(interfaceNames)

	// Generate interfaces
	for _, name := range interfaceNames {
		sb.WriteString("export interface ")
		sb.WriteString(name)
		sb.WriteString(" {\n")
		// TODO: Add fields when available in schema
		sb.WriteString("  // TODO: Add interface fields\n")
		sb.WriteString("}\n\n")
	}
}

// generateUnionTypes generates TypeScript union types
func (p *TypeScriptPlugin) generateUnionTypes(sb *strings.Builder, s schema.Schema) {
	if s == nil {
		return
	}

	typeMap := s.GetTypeMap()
	var unionNames []string

	// Collect all union types
	for name, t := range typeMap {
		if union, ok := t.(*schema.Union); ok {
			unionNames = append(unionNames, name)
			_ = union // Will be used when we have possible types
		}
	}

	// Sort for consistent output
	sort.Strings(unionNames)

	// Generate union types
	for _, name := range unionNames {
		sb.WriteString("export type ")
		sb.WriteString(name)
		sb.WriteString(" =\n")
		// TODO: Add possible types when available in schema
		sb.WriteString("  | PlaceholderType;\n\n")
	}
}

// generateOperationTypes generates TypeScript types for GraphQL operations
func (p *TypeScriptPlugin) generateOperationTypes(sb *strings.Builder, docs []*documents.Document, s schema.Schema, strictNulls bool, scalarMap map[string]string) {
	// Collect all operations
	var operations []*documents.Operation

	for _, doc := range docs {
		operations = append(operations, doc.Operations...)
	}

	// Sort operations by name for consistent output
	sort.Slice(operations, func(i, j int) bool {
		return operations[i].Name < operations[j].Name
	})

	// Generate types for each operation
	for _, op := range operations {
		if op.Name == "" {
			continue // Skip anonymous operations
		}

		// Generate variables type
		sb.WriteString("export interface ")
		sb.WriteString(op.Name)
		sb.WriteString("Variables {\n")

		if len(op.Variables) > 0 {
			for _, v := range op.Variables {
				sb.WriteString("  ")
				sb.WriteString(v.Name)
				if !v.Required && !strictNulls {
					sb.WriteString("?")
				}
				sb.WriteString(": ")
				sb.WriteString(mapGraphQLTypeToTS(v.Type, scalarMap))
				if !v.Required && strictNulls {
					sb.WriteString(" | null")
				}
				sb.WriteString(";\n")
			}
		} else {
			sb.WriteString("  // No variables\n")
		}

		sb.WriteString("}\n\n")

		// Generate result type
		sb.WriteString("export interface ")
		sb.WriteString(op.Name)
		sb.WriteString("Result {\n")
		sb.WriteString("  // TODO: Add result fields based on selection set\n")
		sb.WriteString("}\n\n")
	}
}

// mapGraphQLTypeToTS maps a GraphQL type string to TypeScript
func mapGraphQLTypeToTS(gqlType string, scalarMap map[string]string) string {
	// Remove non-null markers
	// isNonNull := strings.HasSuffix(gqlType, "!") // TODO: use for null handling
	gqlType = strings.TrimSuffix(gqlType, "!")

	// Check if it's a list
	isList := strings.HasPrefix(gqlType, "[") && strings.HasSuffix(gqlType, "]")
	if isList {
		gqlType = strings.TrimPrefix(gqlType, "[")
		gqlType = strings.TrimSuffix(gqlType, "]")
		gqlType = strings.TrimSuffix(gqlType, "!")
	}

	// Map the base type
	var tsType string
	switch gqlType {
	case "ID", "String":
		tsType = "string"
	case "Int", "Float":
		tsType = "number"
	case "Boolean":
		tsType = "boolean"
	default:
		// Check custom scalar mapping
		if mapped, ok := scalarMap[gqlType]; ok {
			tsType = mapped
		} else {
			// Assume it's a custom type
			tsType = gqlType
		}
	}

	// Apply list wrapper
	if isList {
		tsType = tsType + "[]"
	}

	return tsType
}