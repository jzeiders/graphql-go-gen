package typed_document_node

import (
	"bytes"
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/plugins/base"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/formatter"
)

// Plugin generates TypedDocumentNode exports for GraphQL operations
type Plugin struct{}

// New creates a new TypedDocumentNode plugin
func New() plugin.Plugin {
	return &Plugin{}
}

// Name returns the plugin name
func (p *Plugin) Name() string {
	return "typed-document-node"
}

// Description returns the plugin description
func (p *Plugin) Description() string {
	return "Generates TypedDocumentNode exports for GraphQL operations with full type safety"
}

// DefaultConfig returns the default configuration
func (p *Plugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"documentMode":          "graphQLTag",
		"gqlImport":            "graphql-tag",
		"documentNodeImport":   "@graphql-typed-document-node/core",
		"noExport":             false,
		"dedupeOperationSuffix": false,
		"omitOperationSuffix":   false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *Plugin) ValidateConfig(config map[string]interface{}) error {
	mode := base.GetString(config, "documentMode", "graphQLTag")
	validModes := map[string]bool{
		"graphQLTag":     true,
		"documentNode":   true,
		"documentNodeImportExt": true,
		"string":         true,
	}

	if !validModes[mode] {
		return fmt.Errorf("invalid documentMode: %s", mode)
	}

	return nil
}

// Generate generates TypedDocumentNode exports
func (p *Plugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	if len(req.Documents) == 0 {
		// No operations to generate
		return &plugin.GenerateResponse{
			Files: map[string][]byte{
				req.OutputPath: []byte("// No GraphQL operations found\n"),
			},
		}, nil
	}

	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen - TypedDocumentNode Plugin\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	documentMode := base.GetString(req.Config, "documentMode", "graphQLTag")
	gqlImport := base.GetString(req.Config, "gqlImport", "graphql-tag")
	documentNodeImport := base.GetString(req.Config, "documentNodeImport", "@graphql-typed-document-node/core")
	noExport := base.GetBool(req.Config, "noExport", false)
	omitSuffix := base.GetBool(req.Config, "omitOperationSuffix", false)

	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	// Write imports based on mode
	p.writeImports(&sb, documentMode, gqlImport, documentNodeImport)

	// Collect all operations and fragments
	allOps := documents.CollectAllOperations(req.Documents)
	allFrags := documents.CollectAllFragments(req.Documents)

	// Convert to maps for easier access
	opsMap := make(map[string]*ast.OperationDefinition)
	for _, op := range allOps {
		if op.Name != "" {
			opsMap[op.Name] = op
		}
	}

	fragsMap := make(map[string]*ast.FragmentDefinition)
	for _, frag := range allFrags {
		fragsMap[frag.Name] = frag
	}

	// Generate fragments first
	p.generateFragments(&sb, fragsMap, documentMode, exportPrefix)

	// Generate operations
	p.generateOperations(&sb, opsMap, fragsMap, documentMode, omitSuffix, exportPrefix)

	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			req.OutputPath: []byte(sb.String()),
		},
	}, nil
}

// writeImports writes the necessary imports
func (p *Plugin) writeImports(sb *strings.Builder, mode string, gqlImport string, docNodeImport string) {
	switch mode {
	case "graphQLTag":
		sb.WriteString("import gql from '" + gqlImport + "';\n")
		sb.WriteString("import { TypedDocumentNode } from '" + docNodeImport + "';\n\n")
	case "documentNode", "documentNodeImportExt":
		sb.WriteString("import { TypedDocumentNode, DocumentNode } from '" + docNodeImport + "';\n\n")
	case "string":
		sb.WriteString("import { TypedDocumentNode } from '" + docNodeImport + "';\n\n")
	}
}

// generateFragments generates fragment definitions
func (p *Plugin) generateFragments(sb *strings.Builder, fragments map[string]*ast.FragmentDefinition, mode string, exportPrefix string) {
	if len(fragments) == 0 {
		return
	}

	// Sort fragments by name
	var fragNames []string
	for name := range fragments {
		fragNames = append(fragNames, name)
	}
	sort.Strings(fragNames)

	sb.WriteString("// Fragment definitions\n")
	for _, name := range fragNames {
		frag := fragments[name]

		// Convert fragment to string
		var buf bytes.Buffer
		f := formatter.NewFormatter(&buf)
		f.FormatQueryDocument(&ast.QueryDocument{
			Fragments: []*ast.FragmentDefinition{frag},
		})
		fragStr := buf.String()

		constName := name + "FragmentDoc"
		typeName := base.ToPascalCase(name) + "Fragment"

		switch mode {
		case "graphQLTag":
			sb.WriteString(fmt.Sprintf("%sconst %s = gql`\n%s\n` as unknown as TypedDocumentNode<%s, never>;\n\n",
				exportPrefix, constName, fragStr, typeName))
		case "string":
			sb.WriteString(fmt.Sprintf("%sconst %s = `\n%s\n` as unknown as TypedDocumentNode<%s, never>;\n\n",
				exportPrefix, constName, fragStr, typeName))
		case "documentNode", "documentNodeImportExt":
			sb.WriteString(fmt.Sprintf("%sconst %s: TypedDocumentNode<%s, never> = %s;\n\n",
				exportPrefix, constName, typeName, p.generateDocumentNodeAST(frag)))
		}
	}
}

// generateOperations generates operation definitions
func (p *Plugin) generateOperations(sb *strings.Builder, operations map[string]*ast.OperationDefinition, fragments map[string]*ast.FragmentDefinition, mode string, omitSuffix bool, exportPrefix string) {
	if len(operations) == 0 {
		return
	}

	// Sort operations by name
	var opNames []string
	for name := range operations {
		opNames = append(opNames, name)
	}
	sort.Strings(opNames)

	sb.WriteString("// Operation definitions\n")
	for _, name := range opNames {
		op := operations[name]

		// Build the complete operation string with used fragments
		opStr := p.buildOperationString(op, fragments)

		// Determine type names
		constName := base.ToPascalCase(name) + "Document"

		resultTypeName := base.ToPascalCase(name)
		if !omitSuffix {
			switch op.Operation {
			case ast.Query:
				resultTypeName += "Query"
			case ast.Mutation:
				resultTypeName += "Mutation"
			case ast.Subscription:
				resultTypeName += "Subscription"
			}
		}

		varTypeName := "never"
		if len(op.VariableDefinitions) > 0 {
			varTypeName = base.ToPascalCase(name)
			if !omitSuffix {
				switch op.Operation {
				case ast.Query:
					varTypeName += "QueryVariables"
				case ast.Mutation:
					varTypeName += "MutationVariables"
				case ast.Subscription:
					varTypeName += "SubscriptionVariables"
				default:
					varTypeName += "Variables"
				}
			} else {
				varTypeName += "Variables"
			}
		}

		// Generate based on mode
		switch mode {
		case "graphQLTag":
			sb.WriteString(fmt.Sprintf("%sconst %s = gql`\n%s\n` as unknown as TypedDocumentNode<%s, %s>;\n\n",
				exportPrefix, constName, opStr, resultTypeName, varTypeName))
		case "string":
			sb.WriteString(fmt.Sprintf("%sconst %s = `\n%s\n` as unknown as TypedDocumentNode<%s, %s>;\n\n",
				exportPrefix, constName, opStr, resultTypeName, varTypeName))
		case "documentNode", "documentNodeImportExt":
			sb.WriteString(fmt.Sprintf("%sconst %s: TypedDocumentNode<%s, %s> = %s;\n\n",
				exportPrefix, constName, resultTypeName, varTypeName, p.generateOperationNodeAST(op)))
		}
	}
}

// buildOperationString builds the complete operation string including fragments
func (p *Plugin) buildOperationString(op *ast.OperationDefinition, fragments map[string]*ast.FragmentDefinition) string {
	var sb strings.Builder

	// Write the operation
	var buf bytes.Buffer
	f := formatter.NewFormatter(&buf)
	f.FormatQueryDocument(&ast.QueryDocument{
		Operations: []*ast.OperationDefinition{op},
	})
	sb.WriteString(buf.String())

	// Collect used fragments
	usedFragments := p.collectUsedFragments(op.SelectionSet, fragments)

	// Add fragment definitions
	for _, fragName := range usedFragments {
		if frag, ok := fragments[fragName]; ok {
			sb.WriteString("\n\n")
			buf.Reset()
			f := formatter.NewFormatter(&buf)
			f.FormatQueryDocument(&ast.QueryDocument{
				Fragments: []*ast.FragmentDefinition{frag},
			})
			sb.WriteString(buf.String())
		}
	}

	return sb.String()
}

// collectUsedFragments collects all fragments used in a selection set
func (p *Plugin) collectUsedFragments(selSet ast.SelectionSet, fragments map[string]*ast.FragmentDefinition) []string {
	seen := make(map[string]bool)
	var result []string

	var collect func(ast.SelectionSet)
	collect = func(selections ast.SelectionSet) {
		for _, sel := range selections {
			switch s := sel.(type) {
			case *ast.Field:
				if len(s.SelectionSet) > 0 {
					collect(s.SelectionSet)
				}
			case *ast.InlineFragment:
				collect(s.SelectionSet)
			case *ast.FragmentSpread:
				if !seen[s.Name] {
					seen[s.Name] = true
					result = append(result, s.Name)
					// Recursively collect fragments used by this fragment
					if frag, ok := fragments[s.Name]; ok {
						collect(frag.SelectionSet)
					}
				}
			}
		}
	}

	collect(selSet)
	sort.Strings(result)
	return result
}

// generateDocumentNodeAST generates an AST representation for documentNode mode
func (p *Plugin) generateDocumentNodeAST(frag *ast.FragmentDefinition) string {
	// This is a simplified version - in production you'd generate proper AST
	return fmt.Sprintf(`{
  kind: "Document",
  definitions: [{
    kind: "FragmentDefinition",
    name: { kind: "Name", value: "%s" },
    typeCondition: {
      kind: "NamedType",
      name: { kind: "Name", value: "%s" }
    },
    selectionSet: %s
  }]
}`, frag.Name, frag.TypeCondition, p.generateSelectionSetAST(frag.SelectionSet))
}

// generateOperationNodeAST generates an AST representation for an operation
func (p *Plugin) generateOperationNodeAST(op *ast.OperationDefinition) string {
	// This is a simplified version - in production you'd generate proper AST
	opType := "query"
	switch op.Operation {
	case ast.Mutation:
		opType = "mutation"
	case ast.Subscription:
		opType = "subscription"
	}

	return fmt.Sprintf(`{
  kind: "Document",
  definitions: [{
    kind: "OperationDefinition",
    operation: "%s",
    name: { kind: "Name", value: "%s" },
    variableDefinitions: %s,
    selectionSet: %s
  }]
}`, opType, op.Name, p.generateVariableDefsAST(op.VariableDefinitions), p.generateSelectionSetAST(op.SelectionSet))
}

// generateVariableDefsAST generates variable definitions AST
func (p *Plugin) generateVariableDefsAST(vars ast.VariableDefinitionList) string {
	if len(vars) == 0 {
		return "[]"
	}
	// Simplified - would need full implementation
	return "[/* variables */]"
}

// generateSelectionSetAST generates selection set AST
func (p *Plugin) generateSelectionSetAST(selSet ast.SelectionSet) string {
	// Simplified - would need full implementation
	return "{ kind: \"SelectionSet\", selections: [/* selections */] }"
}