package typescript

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/plugins/base"
	"github.com/vektah/gqlparser/v2/ast"
)

// Plugin generates TypeScript type definitions from GraphQL schema
type Plugin struct{}

// New creates a new TypeScript plugin
func New() plugin.Plugin {
	return &Plugin{}
}

// Name returns the plugin name
func (p *Plugin) Name() string {
	return "typescript"
}

// Description returns the plugin description
func (p *Plugin) Description() string {
	return "Generates TypeScript type definitions from GraphQL schema"
}

// DefaultConfig returns the default configuration
func (p *Plugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"strictNulls":     false,
		"enumsAsTypes":    false,
		"immutableTypes":  false,
		"maybeValue":      "T | null",
		"inputMaybeValue": "Maybe<T>",
		"noExport":        false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *Plugin) ValidateConfig(config map[string]interface{}) error {
	return nil
}

const (
	exactSignature        = "type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };"
	makeOptionalSignature = "type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };"
	makeMaybeSignature    = "type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };"
	makeEmptySignature    = "type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };"
	incrementalSignature  = "type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };"
)

type scalarDefinition struct {
	Input  string
	Output string
}

type tsConfig struct {
	strictNulls     bool
	enumsAsTypes    bool
	immutableTypes  bool
	noExport        bool
	maybeValue      string
	inputMaybeValue string
}

type generator struct {
	schema            *ast.Schema
	cfg               tsConfig
	scalars           map[string]scalarDefinition
	customScalarOrder []string
	sb                *strings.Builder
}

// Generate generates TypeScript types from the schema
func (p *Plugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	if req.Schema == nil || req.Schema.Raw() == nil {
		return nil, fmt.Errorf("schema is required")
	}

	astSchema := req.Schema.Raw()

	cfg := tsConfig{
		strictNulls:     base.GetBool(req.Config, "strictNulls", false),
		enumsAsTypes:    base.GetBool(req.Config, "enumsAsTypes", false),
		immutableTypes:  base.GetBool(req.Config, "immutableTypes", false),
		noExport:        base.GetBool(req.Config, "noExport", false),
		maybeValue:      base.GetString(req.Config, "maybeValue", ""),
		inputMaybeValue: base.GetString(req.Config, "inputMaybeValue", ""),
	}

	if req.Options.StrictNulls {
		cfg.strictNulls = true
	}
	if req.Options.EnumsAsTypes {
		cfg.enumsAsTypes = true
	}
	if req.Options.ImmutableTypes {
		cfg.immutableTypes = true
	}

	if cfg.maybeValue == "" {
		cfg.maybeValue = "T | null"
	}
	if cfg.inputMaybeValue == "" {
		cfg.inputMaybeValue = "Maybe<T>"
	}

	scalarDefs, customOrder := buildScalarDefinitions(astSchema, req.ScalarMap)

	var sb strings.Builder
	sb.WriteString("// Generated by graphql-go-gen - TypeScript Plugin\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	gen := generator{
		schema:            astSchema,
		cfg:               cfg,
		scalars:           scalarDefs,
		customScalarOrder: customOrder,
		sb:                &sb,
	}

	gen.writeHelperTypes()
	gen.writeScalars()
	gen.writeEnums()
	gen.writeInputTypes()
	gen.writeObjectTypes()
	gen.writeInterfaceTypes()
	gen.writeUnionTypes()

	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			req.OutputPath: []byte(sb.String()),
		},
	}, nil
}

func buildScalarDefinitions(s *ast.Schema, overrides map[string]string) (map[string]scalarDefinition, []string) {
	result := map[string]scalarDefinition{
		"ID":      {Input: "string", Output: "string"},
		"String":  {Input: "string", Output: "string"},
		"Boolean": {Input: "boolean", Output: "boolean"},
		"Int":     {Input: "number", Output: "number"},
		"Float":   {Input: "number", Output: "number"},
	}

	custom := make(map[string]struct{})
	for name, def := range s.Types {
		if def.Kind == ast.Scalar && !isBuiltInScalar(name) && !strings.HasPrefix(name, "__") {
			custom[name] = struct{}{}
		}
	}
	for name := range overrides {
		if isBuiltInScalar(name) {
			continue
		}
		custom[name] = struct{}{}
	}

	order := make([]string, 0, len(custom))
	for name := range custom {
		order = append(order, name)
	}
	sort.Strings(order)

	for _, name := range order {
		mapped := overrides[name]
		if mapped == "" {
			mapped = "any"
		}
		result[name] = scalarDefinition{Input: mapped, Output: mapped}
	}

	return result, order
}

func isBuiltInScalar(name string) bool {
	switch name {
	case "ID", "String", "Boolean", "Int", "Float":
		return true
	default:
		return false
	}
}

func (g *generator) exportPrefix() string {
	if g.cfg.noExport {
		return ""
	}
	return "export "
}

func (g *generator) writeHelperTypes() {
	exportPrefix := g.exportPrefix()
	g.sb.WriteString(fmt.Sprintf("%stype Maybe<T> = %s;\n", exportPrefix, g.cfg.maybeValue))
	g.sb.WriteString(fmt.Sprintf("%stype InputMaybe<T> = %s;\n", exportPrefix, g.cfg.inputMaybeValue))
	g.sb.WriteString(fmt.Sprintf("%s%s\n", exportPrefix, exactSignature))
	g.sb.WriteString(fmt.Sprintf("%s%s\n", exportPrefix, makeOptionalSignature))
	g.sb.WriteString(fmt.Sprintf("%s%s\n", exportPrefix, makeMaybeSignature))
	g.sb.WriteString(fmt.Sprintf("%s%s\n", exportPrefix, makeEmptySignature))
	g.sb.WriteString(fmt.Sprintf("%s%s\n", exportPrefix, incrementalSignature))
	g.sb.WriteString("\n")
}

func (g *generator) writeScalars() {
	exportPrefix := g.exportPrefix()
	g.sb.WriteString("/** All built-in and custom scalars, mapped to their actual values */\n")
	g.sb.WriteString(fmt.Sprintf("%stype Scalars = {\n", exportPrefix))
	for _, name := range []string{"ID", "String", "Boolean", "Int", "Float"} {
		def := g.scalars[name]
		g.sb.WriteString(fmt.Sprintf("  %s: { input: %s; output: %s };\n", name, def.Input, def.Output))
	}
	for _, name := range g.customScalarOrder {
		def := g.scalars[name]
		g.sb.WriteString(fmt.Sprintf("  %s: { input: %s; output: %s };\n", name, def.Input, def.Output))
	}
	g.sb.WriteString("};\n\n")
}

func (g *generator) writeEnums() {
	enums := g.collectDefinitions(ast.Enum)
	if len(enums) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	for _, enum := range enums {
		if enum.Description != "" {
			g.sb.WriteString(base.FormatComment(enum.Description, ""))
		}
		if g.cfg.enumsAsTypes {
			g.sb.WriteString(fmt.Sprintf("%stype %s =\n", exportPrefix, enum.Name))
			for idx, value := range enum.EnumValues {
				g.sb.WriteString(fmt.Sprintf("  | '%s'", value.Name))
				if value.Description != "" {
					g.sb.WriteString(" // " + strings.ReplaceAll(value.Description, "\n", " "))
				}
				if idx == len(enum.EnumValues)-1 {
					g.sb.WriteString(";\n")
				} else {
					g.sb.WriteString("\n")
				}
			}
		} else {
			g.sb.WriteString(fmt.Sprintf("%senum %s {\n", exportPrefix, enum.Name))
			for _, value := range enum.EnumValues {
				if value.Description != "" {
					g.sb.WriteString(base.FormatComment(value.Description, "  "))
				}
				g.sb.WriteString(fmt.Sprintf("  %s = '%s',\n", value.Name, value.Name))
			}
			g.sb.WriteString("}\n")
		}
		g.sb.WriteString("\n")
	}
}

func (g *generator) writeInputTypes() {
	inputs := g.collectDefinitions(ast.InputObject)
	if len(inputs) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	ctx := g.inputContext()
	for _, input := range inputs {
		if input.Description != "" {
			g.sb.WriteString(base.FormatComment(input.Description, ""))
		}
		g.sb.WriteString(fmt.Sprintf("%stype %s = {\n", exportPrefix, input.Name))
		for _, field := range input.Fields {
			if field.Description != "" {
				g.sb.WriteString(base.FormatComment(field.Description, "  "))
			}
			name := field.Name
			if !isNonNull(field.Type) {
				name += "?"
			}
			g.sb.WriteString("  ")
			if g.cfg.immutableTypes {
				g.sb.WriteString("readonly ")
			}
			g.sb.WriteString(fmt.Sprintf("%s: %s;\n", name, ctx.render(field.Type)))
		}
		g.sb.WriteString("};\n\n")
	}
}

func (g *generator) writeObjectTypes() {
	objects := g.collectDefinitions(ast.Object)
	if len(objects) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	ctx := g.outputContext()
	for _, obj := range objects {
		if obj.Description != "" {
			g.sb.WriteString(base.FormatComment(obj.Description, ""))
		}
		g.sb.WriteString(fmt.Sprintf("%stype %s = {\n", exportPrefix, obj.Name))
		g.sb.WriteString(fmt.Sprintf("  __typename?: '%s';\n", obj.Name))
		for _, field := range obj.Fields {
			if strings.HasPrefix(field.Name, "__") {
				continue
			}
			if field.Description != "" {
				g.sb.WriteString(base.FormatComment(field.Description, "  "))
			}
			name := field.Name
			if !isNonNull(field.Type) {
				name += "?"
			}
			g.sb.WriteString("  ")
			if g.cfg.immutableTypes {
				g.sb.WriteString("readonly ")
			}
			g.sb.WriteString(fmt.Sprintf("%s: %s;\n", name, ctx.render(field.Type)))
		}
		g.sb.WriteString("};\n\n")
		g.writeFieldArguments(obj)
	}
}

func (g *generator) writeFieldArguments(obj *ast.Definition) {
	if len(obj.Fields) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	ctx := g.inputContext()
	for _, field := range obj.Fields {
		if len(field.Arguments) == 0 {
			continue
		}
		name := obj.Name + base.ToPascalCase(field.Name) + "Args"
		g.sb.WriteString(fmt.Sprintf("%stype %s = {\n", exportPrefix, name))
		for _, arg := range field.Arguments {
			if arg.Description != "" {
				g.sb.WriteString(base.FormatComment(arg.Description, "  "))
			}
			prop := arg.Name
			if !isNonNull(arg.Type) {
				prop += "?"
			}
			g.sb.WriteString(fmt.Sprintf("  %s: %s;\n", prop, ctx.render(arg.Type)))
		}
		g.sb.WriteString("};\n\n")
	}
}

func (g *generator) writeInterfaceTypes() {
	interfaces := g.collectDefinitions(ast.Interface)
	if len(interfaces) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	ctx := g.outputContext()
	for _, iface := range interfaces {
		if iface.Description != "" {
			g.sb.WriteString(base.FormatComment(iface.Description, ""))
		}
		g.sb.WriteString(fmt.Sprintf("%stype %s = {\n", exportPrefix, iface.Name))
		for _, field := range iface.Fields {
			if field.Description != "" {
				g.sb.WriteString(base.FormatComment(field.Description, "  "))
			}
			name := field.Name
			if !isNonNull(field.Type) {
				name += "?"
			}
			g.sb.WriteString("  ")
			if g.cfg.immutableTypes {
				g.sb.WriteString("readonly ")
			}
			g.sb.WriteString(fmt.Sprintf("%s: %s;\n", name, ctx.render(field.Type)))
		}
		g.sb.WriteString("};\n\n")
	}
}

func (g *generator) writeUnionTypes() {
	unions := g.collectDefinitions(ast.Union)
	if len(unions) == 0 {
		return
	}
	exportPrefix := g.exportPrefix()
	ctx := g.outputContext()
	for _, union := range unions {
		if union.Description != "" {
			g.sb.WriteString(base.FormatComment(union.Description, ""))
		}
		members := make([]string, 0, len(union.Types))
		for _, named := range union.Types {
			members = append(members, ctx.namedType(named))
		}
		g.sb.WriteString(fmt.Sprintf("%stype %s = %s;\n\n", exportPrefix, union.Name, strings.Join(members, " | ")))
	}
}

func (g *generator) collectDefinitions(kind ast.DefinitionKind) []*ast.Definition {
	var defs []*ast.Definition
	for _, def := range g.schema.Types {
		if def.Kind == kind && !strings.HasPrefix(def.Name, "__") {
			defs = append(defs, def)
		}
	}
	if len(defs) > 1 {
		sort.Slice(defs, func(i, j int) bool {
			return defs[i].Name < defs[j].Name
		})
	}
	return defs
}

type typeContext struct {
	schema       *ast.Schema
	scalars      map[string]scalarDefinition
	immutable    bool
	maybeWrapper string
	scalarUsage  string
}

func (g *generator) outputContext() typeContext {
	return typeContext{
		schema:       g.schema,
		scalars:      g.scalars,
		immutable:    g.cfg.immutableTypes,
		maybeWrapper: "Maybe",
		scalarUsage:  "output",
	}
}

func (g *generator) inputContext() typeContext {
	return typeContext{
		schema:       g.schema,
		scalars:      g.scalars,
		immutable:    g.cfg.immutableTypes,
		maybeWrapper: "InputMaybe",
		scalarUsage:  "input",
	}
}

func (ctx typeContext) render(t *ast.Type) string {
	if t == nil {
		return "any"
	}
	if !t.NonNull {
		nn := *t
		nn.NonNull = true
		return fmt.Sprintf("%s<%s>", ctx.maybeWrapper, ctx.renderNonNull(&nn))
	}
	return ctx.renderNonNull(t)
}

func (ctx typeContext) renderNonNull(t *ast.Type) string {
	if t.Elem != nil {
		inner := ctx.render(t.Elem)
		if ctx.immutable {
			return fmt.Sprintf("ReadonlyArray<%s>", inner)
		}
		return fmt.Sprintf("Array<%s>", inner)
	}
	return ctx.namedType(t.NamedType)
}

func (ctx typeContext) namedType(name string) string {
	if _, ok := ctx.scalars[name]; ok {
		if ctx.scalarUsage == "input" {
			return fmt.Sprintf("Scalars['%s']['input']", name)
		}
		return fmt.Sprintf("Scalars['%s']['output']", name)
	}
	return name
}

func isNonNull(t *ast.Type) bool {
	if t == nil {
		return false
	}
	return t.NonNull
}
