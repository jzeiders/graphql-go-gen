package typescript

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/plugins/base"
	"github.com/vektah/gqlparser/v2/ast"
)

// Plugin generates TypeScript type definitions from GraphQL schema
type Plugin struct{}

// New creates a new TypeScript plugin
func New() plugin.Plugin {
	return &Plugin{}
}

// Name returns the plugin name
func (p *Plugin) Name() string {
	return "typescript"
}

// Description returns the plugin description
func (p *Plugin) Description() string {
	return "Generates TypeScript type definitions from GraphQL schema"
}

// DefaultConfig returns the default configuration
func (p *Plugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"strictNulls":     false,
		"enumsAsTypes":    false,
		"immutableTypes":  false,
		"maybeValue":      "T | null",
		"inputMaybeValue": "Maybe<T>",
		"noExport":        false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *Plugin) ValidateConfig(config map[string]interface{}) error {
	return nil
}

// Generate generates TypeScript types from the schema
func (p *Plugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	if req.Schema == nil || req.Schema.Raw() == nil {
		return nil, fmt.Errorf("schema is required")
	}

	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen - TypeScript Plugin\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	strictNulls := base.GetBool(req.Config, "strictNulls", false)
	enumsAsTypes := base.GetBool(req.Config, "enumsAsTypes", false)
	immutableTypes := base.GetBool(req.Config, "immutableTypes", false)
	noExport := base.GetBool(req.Config, "noExport", false)

	// Override with global options if set
	if req.Options.StrictNulls {
		strictNulls = true
	}
	if req.Options.EnumsAsTypes {
		enumsAsTypes = true
	}
	if req.Options.ImmutableTypes {
		immutableTypes = true
	}

	astSchema := req.Schema.Raw()

	// Generate types in order
	p.generateScalarTypes(&sb, astSchema, req.ScalarMap, noExport)
	p.generateEnumTypes(&sb, astSchema, enumsAsTypes, noExport)
	p.generateInputTypes(&sb, astSchema, strictNulls, immutableTypes, req.ScalarMap, noExport)
	p.generateObjectTypes(&sb, astSchema, strictNulls, immutableTypes, req.ScalarMap, noExport)
	p.generateInterfaceTypes(&sb, astSchema, strictNulls, immutableTypes, req.ScalarMap, noExport)
	p.generateUnionTypes(&sb, astSchema, noExport)

	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			req.OutputPath: []byte(sb.String()),
		},
	}, nil
}

// generateScalarTypes generates TypeScript scalar type mappings
func (p *Plugin) generateScalarTypes(sb *strings.Builder, s *ast.Schema, scalarMap map[string]string, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	sb.WriteString("// Scalar types\n")
	sb.WriteString(exportPrefix + "type Scalars = {\n")

	// Built-in scalars
	sb.WriteString("  ID: string;\n")
	sb.WriteString("  String: string;\n")
	sb.WriteString("  Boolean: boolean;\n")
	sb.WriteString("  Int: number;\n")
	sb.WriteString("  Float: number;\n")

	// Custom scalars
	var customScalars []string
	for name := range s.Types {
		if def, ok := s.Types[name]; ok && def.Kind == ast.Scalar {
			if name != "ID" && name != "String" && name != "Boolean" && name != "Int" && name != "Float" {
				customScalars = append(customScalars, name)
			}
		}
	}

	sort.Strings(customScalars)
	for _, name := range customScalars {
		tsType := "unknown"
		if mapped, ok := scalarMap[name]; ok {
			tsType = mapped
		}
		sb.WriteString(fmt.Sprintf("  %s: %s;\n", name, tsType))
	}

	sb.WriteString("};\n\n")
}

// generateEnumTypes generates TypeScript enum types
func (p *Plugin) generateEnumTypes(sb *strings.Builder, s *ast.Schema, enumsAsTypes bool, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	var enums []*ast.Definition
	for _, def := range s.Types {
		if def.Kind == ast.Enum && !strings.HasPrefix(def.Name, "__") {
			enums = append(enums, def)
		}
	}

	if len(enums) == 0 {
		return
	}

	sort.Slice(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})

	sb.WriteString("// Enum types\n")
	for _, enum := range enums {
		if enum.Description != "" {
			sb.WriteString(base.FormatComment(enum.Description, ""))
		}

		if enumsAsTypes {
			// Generate as union types
			sb.WriteString(exportPrefix + "type " + enum.Name + " =\n")
			for i, value := range enum.EnumValues {
				sb.WriteString("  | '" + value.Name + "'")
				if value.Description != "" {
					sb.WriteString(" // " + strings.ReplaceAll(value.Description, "\n", " "))
				}
				if i < len(enum.EnumValues)-1 {
					sb.WriteString("\n")
				} else {
					sb.WriteString(";\n")
				}
			}
		} else {
			// Generate as const enums
			sb.WriteString(exportPrefix + "enum " + enum.Name + " {\n")
			for _, value := range enum.EnumValues {
				if value.Description != "" {
					sb.WriteString(base.FormatComment(value.Description, "  "))
				}
				sb.WriteString("  " + value.Name + " = '" + value.Name + "',\n")
			}
			sb.WriteString("}\n")
		}
		sb.WriteString("\n")
	}
}

// generateInputTypes generates TypeScript input types
func (p *Plugin) generateInputTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, immutableTypes bool, scalarMap map[string]string, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	var inputs []*ast.Definition
	for _, def := range s.Types {
		if def.Kind == ast.InputObject {
			inputs = append(inputs, def)
		}
	}

	if len(inputs) == 0 {
		return
	}

	sort.Slice(inputs, func(i, j int) bool {
		return inputs[i].Name < inputs[j].Name
	})

	sb.WriteString("// Input types\n")
	for _, input := range inputs {
		if input.Description != "" {
			sb.WriteString(base.FormatComment(input.Description, ""))
		}

		sb.WriteString(exportPrefix + "type " + input.Name + " = {\n")
		for _, field := range input.Fields {
			if field.Description != "" {
				sb.WriteString(base.FormatComment(field.Description, "  "))
			}

			fieldName := field.Name
			if !field.Type.NonNull {
				fieldName += "?"
			}
			if immutableTypes {
				sb.WriteString("  readonly ")
			} else {
				sb.WriteString("  ")
			}

			tsType := base.TypeToTypeScript(field.Type, scalarMap, strictNulls)
			sb.WriteString(fieldName + ": " + tsType + ";\n")
		}
		sb.WriteString("};\n\n")
	}
}

// generateObjectTypes generates TypeScript object types
func (p *Plugin) generateObjectTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, immutableTypes bool, scalarMap map[string]string, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	var objects []*ast.Definition
	for _, def := range s.Types {
		if def.Kind == ast.Object && !strings.HasPrefix(def.Name, "__") {
			// Skip Query, Mutation, Subscription root types for now
			if def.Name != s.Query.Name &&
			   (s.Mutation == nil || def.Name != s.Mutation.Name) &&
			   (s.Subscription == nil || def.Name != s.Subscription.Name) {
				objects = append(objects, def)
			}
		}
	}

	if len(objects) == 0 {
		return
	}

	sort.Slice(objects, func(i, j int) bool {
		return objects[i].Name < objects[j].Name
	})

	sb.WriteString("// Object types\n")
	for _, obj := range objects {
		if obj.Description != "" {
			sb.WriteString(base.FormatComment(obj.Description, ""))
		}

		sb.WriteString(exportPrefix + "type " + obj.Name + " = {\n")
		sb.WriteString("  __typename?: '" + obj.Name + "';\n")

		for _, field := range obj.Fields {
			if strings.HasPrefix(field.Name, "__") {
				continue
			}

			if field.Description != "" {
				sb.WriteString(base.FormatComment(field.Description, "  "))
			}

			if immutableTypes {
				sb.WriteString("  readonly ")
			} else {
				sb.WriteString("  ")
			}

			tsType := base.TypeToTypeScript(field.Type, scalarMap, strictNulls)
			sb.WriteString(field.Name + ": " + tsType + ";\n")
		}
		sb.WriteString("};\n\n")
	}

	// Generate root types
	if s.Query != nil {
		p.generateRootType(sb, s, s.Query, "Query", strictNulls, immutableTypes, scalarMap, noExport)
	}
	if s.Mutation != nil {
		p.generateRootType(sb, s, s.Mutation, "Mutation", strictNulls, immutableTypes, scalarMap, noExport)
	}
	if s.Subscription != nil {
		p.generateRootType(sb, s, s.Subscription, "Subscription", strictNulls, immutableTypes, scalarMap, noExport)
	}
}

// generateRootType generates a root type (Query, Mutation, Subscription)
func (p *Plugin) generateRootType(sb *strings.Builder, s *ast.Schema, def *ast.Definition, typeName string, strictNulls bool, immutableTypes bool, scalarMap map[string]string, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	sb.WriteString(fmt.Sprintf("// %s root type\n", typeName))
	sb.WriteString(exportPrefix + "type " + typeName + " = {\n")
	sb.WriteString("  __typename?: '" + typeName + "';\n")

	for _, field := range def.Fields {
		if strings.HasPrefix(field.Name, "__") {
			continue
		}

		if field.Description != "" {
			sb.WriteString(base.FormatComment(field.Description, "  "))
		}

		if immutableTypes {
			sb.WriteString("  readonly ")
		} else {
			sb.WriteString("  ")
		}

		tsType := base.TypeToTypeScript(field.Type, scalarMap, strictNulls)
		sb.WriteString(field.Name + ": " + tsType + ";\n")
	}
	sb.WriteString("};\n\n")
}

// generateInterfaceTypes generates TypeScript interface types
func (p *Plugin) generateInterfaceTypes(sb *strings.Builder, s *ast.Schema, strictNulls bool, immutableTypes bool, scalarMap map[string]string, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	var interfaces []*ast.Definition
	for _, def := range s.Types {
		if def.Kind == ast.Interface && !strings.HasPrefix(def.Name, "__") {
			interfaces = append(interfaces, def)
		}
	}

	if len(interfaces) == 0 {
		return
	}

	sort.Slice(interfaces, func(i, j int) bool {
		return interfaces[i].Name < interfaces[j].Name
	})

	sb.WriteString("// Interface types\n")
	for _, iface := range interfaces {
		if iface.Description != "" {
			sb.WriteString(base.FormatComment(iface.Description, ""))
		}

		sb.WriteString(exportPrefix + "type " + iface.Name + " = {\n")

		for _, field := range iface.Fields {
			if field.Description != "" {
				sb.WriteString(base.FormatComment(field.Description, "  "))
			}

			if immutableTypes {
				sb.WriteString("  readonly ")
			} else {
				sb.WriteString("  ")
			}

			tsType := base.TypeToTypeScript(field.Type, scalarMap, strictNulls)
			sb.WriteString(field.Name + ": " + tsType + ";\n")
		}
		sb.WriteString("};\n\n")
	}
}

// generateUnionTypes generates TypeScript union types
func (p *Plugin) generateUnionTypes(sb *strings.Builder, s *ast.Schema, noExport bool) {
	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	var unions []*ast.Definition
	for _, def := range s.Types {
		if def.Kind == ast.Union && !strings.HasPrefix(def.Name, "__") {
			unions = append(unions, def)
		}
	}

	if len(unions) == 0 {
		return
	}

	sort.Slice(unions, func(i, j int) bool {
		return unions[i].Name < unions[j].Name
	})

	sb.WriteString("// Union types\n")
	for _, union := range unions {
		if union.Description != "" {
			sb.WriteString(base.FormatComment(union.Description, ""))
		}

		sb.WriteString(exportPrefix + "type " + union.Name + " =\n")
		for i, member := range union.Types {
			if i < len(union.Types)-1 {
				sb.WriteString("  | " + member + "\n")
			} else {
				sb.WriteString("  | " + member + ";\n")
			}
		}
		sb.WriteString("\n")
	}
}
