package schema_ast

import (
	"bytes"
	"context"
	"fmt"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/plugins/base"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/formatter"
)

// Plugin generates the GraphQL schema as an AST export
type Plugin struct{}

// New creates a new Schema AST plugin
func New() plugin.Plugin {
	return &Plugin{}
}

// Name returns the plugin name
func (p *Plugin) Name() string {
	return "schema-ast"
}

// Description returns the plugin description
func (p *Plugin) Description() string {
	return "Generates GraphQL schema as TypeScript/JavaScript AST or SDL string export"
}

// DefaultConfig returns the default configuration
func (p *Plugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"outputFormat":     "graphql",    // "graphql", "introspection", "ast"
		"includeDirectives": true,
		"includeIntrospection": false,
		"commentDescriptions": true,
		"noExport": false,
		"constName": "schema",
	}
}

// ValidateConfig validates the plugin configuration
func (p *Plugin) ValidateConfig(config map[string]interface{}) error {
	format := base.GetString(config, "outputFormat", "graphql")
	validFormats := map[string]bool{
		"graphql":       true,
		"introspection": true,
		"ast":          true,
	}

	if !validFormats[format] {
		return fmt.Errorf("invalid outputFormat: %s", format)
	}

	return nil
}

// Generate generates the schema export
func (p *Plugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	if req.Schema == nil || req.Schema.Raw() == nil {
		return nil, fmt.Errorf("schema is required")
	}

	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen - Schema AST Plugin\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	outputFormat := base.GetString(req.Config, "outputFormat", "graphql")
	includeDirectives := base.GetBool(req.Config, "includeDirectives", true)
	includeIntrospection := base.GetBool(req.Config, "includeIntrospection", false)
	commentDescriptions := base.GetBool(req.Config, "commentDescriptions", true)
	noExport := base.GetBool(req.Config, "noExport", false)
	constName := base.GetString(req.Config, "constName", "schema")

	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	astSchema := req.Schema.Raw()

	switch outputFormat {
	case "graphql":
		p.generateGraphQLSDL(&sb, astSchema, includeDirectives, includeIntrospection, commentDescriptions, exportPrefix, constName)
	case "introspection":
		p.generateIntrospectionJSON(&sb, req.Schema, exportPrefix, constName)
	case "ast":
		p.generateASTExport(&sb, astSchema, exportPrefix, constName)
	}

	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			req.OutputPath: []byte(sb.String()),
		},
	}, nil
}

// generateGraphQLSDL generates the schema as a GraphQL SDL string
func (p *Plugin) generateGraphQLSDL(sb *strings.Builder, schema *ast.Schema, includeDirectives bool, includeIntrospection bool, commentDescriptions bool, exportPrefix string, constName string) {
	// Import graphql-tag if needed
	sb.WriteString("import { buildSchema } from 'graphql';\n\n")

	// Generate SDL
	var buf bytes.Buffer
	f := formatter.NewFormatter(&buf)

	// Format the schema
	f.FormatSchema(schema)

	sdl := buf.String()

	// Clean up the SDL
	if !includeIntrospection {
		sdl = p.removeIntrospectionTypes(sdl)
	}

	// Export as a const
	sb.WriteString(fmt.Sprintf("%sconst %sSDL = `%s`;\n\n", exportPrefix, constName, sdl))

	// Also export as a parsed schema
	sb.WriteString(fmt.Sprintf("%sconst %s = buildSchema(%sSDL);\n", exportPrefix, constName, constName))
}

// generateIntrospectionJSON generates the schema as introspection JSON
func (p *Plugin) generateIntrospectionJSON(sb *strings.Builder, schema interface{ Raw() *ast.Schema }, exportPrefix string, constName string) {
	sb.WriteString("// Schema introspection result\n")

	// This would require implementing introspection query execution
	// For now, we'll generate a placeholder
	sb.WriteString(fmt.Sprintf("%sconst %sIntrospection = {\n", exportPrefix, constName))
	sb.WriteString("  __schema: {\n")
	sb.WriteString("    types: [],\n")
	sb.WriteString("    queryType: { name: 'Query' },\n")

	if schema.Raw().Mutation != nil {
		sb.WriteString("    mutationType: { name: 'Mutation' },\n")
	} else {
		sb.WriteString("    mutationType: null,\n")
	}

	if schema.Raw().Subscription != nil {
		sb.WriteString("    subscriptionType: { name: 'Subscription' },\n")
	} else {
		sb.WriteString("    subscriptionType: null,\n")
	}

	sb.WriteString("    directives: []\n")
	sb.WriteString("  }\n")
	sb.WriteString("};\n\n")

	sb.WriteString("// Note: This is a simplified introspection result.\n")
	sb.WriteString("// For full introspection, execute an introspection query against your schema.\n")
}

// generateASTExport generates the schema as a JavaScript AST
func (p *Plugin) generateASTExport(sb *strings.Builder, schema *ast.Schema, exportPrefix string, constName string) {
	sb.WriteString("import { DocumentNode } from 'graphql';\n\n")
	sb.WriteString("// Schema as GraphQL AST\n")
	sb.WriteString(fmt.Sprintf("%sconst %sAST: DocumentNode = {\n", exportPrefix, constName))
	sb.WriteString("  kind: 'Document',\n")
	sb.WriteString("  definitions: [\n")

	// Generate type definitions
	first := true
	for _, typ := range schema.Types {
		if strings.HasPrefix(typ.Name, "__") {
			continue // Skip introspection types
		}

		if !first {
			sb.WriteString(",\n")
		}
		first = false

		p.generateTypeDefinitionAST(sb, typ, "    ")
	}

	// Add schema definition if it has custom names
	if schema.Query != nil || schema.Mutation != nil || schema.Subscription != nil {
		if !first {
			sb.WriteString(",\n")
		}
		p.generateSchemaDefinitionAST(sb, schema, "    ")
	}

	sb.WriteString("\n  ]\n")
	sb.WriteString("};\n")
}

// generateTypeDefinitionAST generates AST for a type definition
func (p *Plugin) generateTypeDefinitionAST(sb *strings.Builder, typ *ast.Definition, indent string) {
	sb.WriteString(indent + "{\n")

	switch typ.Kind {
	case ast.Scalar:
		sb.WriteString(indent + "  kind: 'ScalarTypeDefinition',\n")
	case ast.Object:
		sb.WriteString(indent + "  kind: 'ObjectTypeDefinition',\n")
	case ast.Interface:
		sb.WriteString(indent + "  kind: 'InterfaceTypeDefinition',\n")
	case ast.Union:
		sb.WriteString(indent + "  kind: 'UnionTypeDefinition',\n")
	case ast.Enum:
		sb.WriteString(indent + "  kind: 'EnumTypeDefinition',\n")
	case ast.InputObject:
		sb.WriteString(indent + "  kind: 'InputObjectTypeDefinition',\n")
	}

	sb.WriteString(fmt.Sprintf("%s  name: { kind: 'Name', value: '%s' }", indent, typ.Name))

	// Add fields for object/interface types
	if typ.Kind == ast.Object || typ.Kind == ast.Interface {
		sb.WriteString(",\n" + indent + "  fields: [")
		for i, field := range typ.Fields {
			if i > 0 {
				sb.WriteString(",")
			}
			sb.WriteString("\n" + indent + "    {")
			sb.WriteString("\n" + indent + "      kind: 'FieldDefinition',")
			sb.WriteString(fmt.Sprintf("\n%s      name: { kind: 'Name', value: '%s' },", indent, field.Name))
			sb.WriteString(fmt.Sprintf("\n%s      type: %s", indent, p.generateTypeAST(field.Type)))
			sb.WriteString("\n" + indent + "    }")
		}
		if len(typ.Fields) > 0 {
			sb.WriteString("\n" + indent + "  ")
		}
		sb.WriteString("]")
	}

	// Add enum values
	if typ.Kind == ast.Enum {
		sb.WriteString(",\n" + indent + "  values: [")
		for i, val := range typ.EnumValues {
			if i > 0 {
				sb.WriteString(",")
			}
			sb.WriteString("\n" + indent + "    {")
			sb.WriteString("\n" + indent + "      kind: 'EnumValueDefinition',")
			sb.WriteString(fmt.Sprintf("\n%s      name: { kind: 'Name', value: '%s' }", indent, val.Name))
			sb.WriteString("\n" + indent + "    }")
		}
		if len(typ.EnumValues) > 0 {
			sb.WriteString("\n" + indent + "  ")
		}
		sb.WriteString("]")
	}

	// Add union members
	if typ.Kind == ast.Union {
		sb.WriteString(",\n" + indent + "  types: [")
		for i, member := range typ.Types {
			if i > 0 {
				sb.WriteString(",")
			}
			sb.WriteString(fmt.Sprintf("\n%s    { kind: 'NamedType', name: { kind: 'Name', value: '%s' } }", indent, member))
		}
		if len(typ.Types) > 0 {
			sb.WriteString("\n" + indent + "  ")
		}
		sb.WriteString("]")
	}

	// Add input fields
	if typ.Kind == ast.InputObject {
		sb.WriteString(",\n" + indent + "  fields: [")
		for i, field := range typ.Fields {
			if i > 0 {
				sb.WriteString(",")
			}
			sb.WriteString("\n" + indent + "    {")
			sb.WriteString("\n" + indent + "      kind: 'InputValueDefinition',")
			sb.WriteString(fmt.Sprintf("\n%s      name: { kind: 'Name', value: '%s' },", indent, field.Name))
			sb.WriteString(fmt.Sprintf("\n%s      type: %s", indent, p.generateTypeAST(field.Type)))
			sb.WriteString("\n" + indent + "    }")
		}
		if len(typ.Fields) > 0 {
			sb.WriteString("\n" + indent + "  ")
		}
		sb.WriteString("]")
	}

	sb.WriteString("\n" + indent + "}")
}

// generateSchemaDefinitionAST generates AST for schema definition
func (p *Plugin) generateSchemaDefinitionAST(sb *strings.Builder, schema *ast.Schema, indent string) {
	sb.WriteString(indent + "{\n")
	sb.WriteString(indent + "  kind: 'SchemaDefinition',\n")
	sb.WriteString(indent + "  operationTypes: [")

	ops := 0
	if schema.Query != nil {
		sb.WriteString("\n" + indent + "    {")
		sb.WriteString("\n" + indent + "      kind: 'OperationTypeDefinition',")
		sb.WriteString("\n" + indent + "      operation: 'query',")
		sb.WriteString(fmt.Sprintf("\n%s      type: { kind: 'NamedType', name: { kind: 'Name', value: '%s' } }", indent, schema.Query.Name))
		sb.WriteString("\n" + indent + "    }")
		ops++
	}

	if schema.Mutation != nil {
		if ops > 0 {
			sb.WriteString(",")
		}
		sb.WriteString("\n" + indent + "    {")
		sb.WriteString("\n" + indent + "      kind: 'OperationTypeDefinition',")
		sb.WriteString("\n" + indent + "      operation: 'mutation',")
		sb.WriteString(fmt.Sprintf("\n%s      type: { kind: 'NamedType', name: { kind: 'Name', value: '%s' } }", indent, schema.Mutation.Name))
		sb.WriteString("\n" + indent + "    }")
		ops++
	}

	if schema.Subscription != nil {
		if ops > 0 {
			sb.WriteString(",")
		}
		sb.WriteString("\n" + indent + "    {")
		sb.WriteString("\n" + indent + "      kind: 'OperationTypeDefinition',")
		sb.WriteString("\n" + indent + "      operation: 'subscription',")
		sb.WriteString(fmt.Sprintf("\n%s      type: { kind: 'NamedType', name: { kind: 'Name', value: '%s' } }", indent, schema.Subscription.Name))
		sb.WriteString("\n" + indent + "    }")
	}

	if ops > 0 {
		sb.WriteString("\n" + indent + "  ")
	}
	sb.WriteString("]\n")
	sb.WriteString(indent + "}")
}

// generateTypeAST generates AST for a type reference
func (p *Plugin) generateTypeAST(typ *ast.Type) string {
	if typ.NonNull {
		inner := p.generateTypeASTInner(typ)
		return fmt.Sprintf("{ kind: 'NonNullType', type: %s }", inner)
	}
	return p.generateTypeASTInner(typ)
}

// generateTypeASTInner generates inner type AST
func (p *Plugin) generateTypeASTInner(typ *ast.Type) string {
	if typ.Elem != nil {
		inner := p.generateTypeAST(typ.Elem)
		return fmt.Sprintf("{ kind: 'ListType', type: %s }", inner)
	}
	return fmt.Sprintf("{ kind: 'NamedType', name: { kind: 'Name', value: '%s' } }", typ.NamedType)
}

// removeIntrospectionTypes removes introspection types from SDL
func (p *Plugin) removeIntrospectionTypes(sdl string) string {
	lines := strings.Split(sdl, "\n")
	var result []string
	skipUntilBrace := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Check if we should start skipping
		if strings.HasPrefix(trimmed, "type __") ||
		   strings.HasPrefix(trimmed, "enum __") ||
		   strings.HasPrefix(trimmed, "scalar __") {
			skipUntilBrace = true
			continue
		}

		// If we're skipping, check for closing brace
		if skipUntilBrace {
			if strings.Contains(line, "}") {
				skipUntilBrace = false
			}
			continue
		}

		// Skip introspection field definitions
		if strings.Contains(trimmed, "__type") ||
		   strings.Contains(trimmed, "__schema") ||
		   strings.Contains(trimmed, "__typename") {
			continue
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}