package typescript_operations

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/jzeiders/graphql-go-gen/pkg/documents"
	"github.com/jzeiders/graphql-go-gen/pkg/plugin"
	"github.com/jzeiders/graphql-go-gen/pkg/plugins/base"
	"github.com/vektah/gqlparser/v2/ast"
)

// Plugin generates TypeScript types for GraphQL operations
type Plugin struct{}

// New creates a new TypeScript operations plugin
func New() plugin.Plugin {
	return &Plugin{}
}

// Name returns the plugin name
func (p *Plugin) Name() string {
	return "typescript-operations"
}

// Description returns the plugin description
func (p *Plugin) Description() string {
	return "Generates TypeScript types for GraphQL operations (queries, mutations, subscriptions)"
}

// DefaultConfig returns the default configuration
func (p *Plugin) DefaultConfig() map[string]interface{} {
	return map[string]interface{}{
		"strictNulls":           false,
		"immutableTypes":        false,
		"noExport":              false,
		"preResolveTypes":       false,
		"skipTypename":          false,
		"dedupeOperationSuffix": false,
		"omitOperationSuffix":   false,
	}
}

// ValidateConfig validates the plugin configuration
func (p *Plugin) ValidateConfig(config map[string]interface{}) error {
	return nil
}

// Generate generates TypeScript operation types
func (p *Plugin) Generate(ctx context.Context, req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	if req.Schema == nil || req.Schema.Raw() == nil {
		return nil, fmt.Errorf("schema is required")
	}

	if len(req.Documents) == 0 {
		// No operations to generate
		return &plugin.GenerateResponse{
			Files: map[string][]byte{
				req.OutputPath: []byte("// No GraphQL operations found\n"),
			},
		}, nil
	}

	var sb strings.Builder

	// Write header
	sb.WriteString("// Generated by graphql-go-gen - TypeScript Operations Plugin\n")
	sb.WriteString("// DO NOT EDIT THIS FILE MANUALLY\n\n")

	// Get configuration
	strictNulls := base.GetBool(req.Config, "strictNulls", false)
	immutableTypes := base.GetBool(req.Config, "immutableTypes", false)
	noExport := base.GetBool(req.Config, "noExport", false)
	skipTypename := base.GetBool(req.Config, "skipTypename", false)
	omitOperationSuffix := base.GetBool(req.Config, "omitOperationSuffix", false)

	// Override with global options if set
	if req.Options.StrictNulls {
		strictNulls = true
	}
	if req.Options.ImmutableTypes {
		immutableTypes = true
	}
	if req.Options.SkipTypename {
		skipTypename = true
	}

	astSchema := req.Schema.Raw()

	// Collect all operations and fragments
	allOps := documents.CollectAllOperations(req.Documents)
	allFrags := documents.CollectAllFragments(req.Documents)

	// Convert to maps for easier access
	opsMap := make(map[string]*ast.OperationDefinition)
	for _, op := range allOps {
		if op.Name != "" {
			opsMap[op.Name] = op
		}
	}

	fragsMap := make(map[string]*ast.FragmentDefinition)
	for _, frag := range allFrags {
		fragsMap[frag.Name] = frag
	}

	// Generate fragment types first
	p.generateFragmentTypes(&sb, fragsMap, astSchema, strictNulls, immutableTypes, skipTypename, req.ScalarMap, noExport)

	// Generate operation types
	p.generateOperationTypes(&sb, opsMap, astSchema, strictNulls, immutableTypes, skipTypename, omitOperationSuffix, req.ScalarMap, noExport)

	return &plugin.GenerateResponse{
		Files: map[string][]byte{
			req.OutputPath: []byte(sb.String()),
		},
	}, nil
}

// generateFragmentTypes generates types for GraphQL fragments
func (p *Plugin) generateFragmentTypes(sb *strings.Builder, fragments map[string]*ast.FragmentDefinition, s *ast.Schema, strictNulls bool, immutableTypes bool, skipTypename bool, scalarMap map[string]string, noExport bool) {
	if len(fragments) == 0 {
		return
	}

	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	// Sort fragments by name
	var fragNames []string
	for name := range fragments {
		fragNames = append(fragNames, name)
	}
	sort.Strings(fragNames)

	sb.WriteString("// Fragment types\n")
	for _, name := range fragNames {
		frag := fragments[name]
		typeName := base.ToPascalCase(name) + "Fragment"

		sb.WriteString(exportPrefix + "type " + typeName + " = {\n")

		hasTypename := selectionHasExplicitTypename(frag.SelectionSet)
		if !skipTypename && !hasTypename {
			sb.WriteString("  __typename?: '" + frag.TypeCondition + "';\n")
		}

		p.generateSelectionSetTypes(sb, frag.SelectionSet, s, strictNulls, immutableTypes, skipTypename, scalarMap, "  ")
		sb.WriteString("};\n\n")
	}
}

// generateOperationTypes generates types for GraphQL operations
func (p *Plugin) generateOperationTypes(sb *strings.Builder, operations map[string]*ast.OperationDefinition, s *ast.Schema, strictNulls bool, immutableTypes bool, skipTypename bool, omitSuffix bool, scalarMap map[string]string, noExport bool) {
	if len(operations) == 0 {
		return
	}

	exportPrefix := "export "
	if noExport {
		exportPrefix = ""
	}

	// Sort operations by name
	var opNames []string
	for name := range operations {
		opNames = append(opNames, name)
	}
	sort.Strings(opNames)

	sb.WriteString("// Operation types\n")
	for _, name := range opNames {
		op := operations[name]

		// Generate variable types if the operation has variables
		if len(op.VariableDefinitions) > 0 {
			varTypeName := base.ToPascalCase(name)
			if !omitSuffix {
				switch op.Operation {
				case ast.Query:
					varTypeName += "QueryVariables"
				case ast.Mutation:
					varTypeName += "MutationVariables"
				case ast.Subscription:
					varTypeName += "SubscriptionVariables"
				default:
					varTypeName += "Variables"
				}
			} else {
				varTypeName += "Variables"
			}

			sb.WriteString(exportPrefix + "type " + varTypeName + " = {\n")
			for _, varDef := range op.VariableDefinitions {
				if immutableTypes {
					sb.WriteString("  readonly ")
				} else {
					sb.WriteString("  ")
				}

				varName := varDef.Variable
				if !varDef.Type.NonNull {
					varName += "?"
				}

				tsType := base.TypeToTypeScript(varDef.Type, scalarMap, strictNulls)
				sb.WriteString(varName + ": " + tsType + ";\n")
			}
			sb.WriteString("};\n\n")
		}

		// Generate result type
		resultTypeName := base.ToPascalCase(name)
		if !omitSuffix {
			switch op.Operation {
			case ast.Query:
				resultTypeName += "Query"
			case ast.Mutation:
				resultTypeName += "Mutation"
			case ast.Subscription:
				resultTypeName += "Subscription"
			}
		}

		sb.WriteString(exportPrefix + "type " + resultTypeName + " = {\n")

		hasTypename := selectionHasExplicitTypename(op.SelectionSet)

		// Add __typename for root type if not skipped and not explicitly selected
		if !skipTypename && !hasTypename {
			switch op.Operation {
			case ast.Query:
				sb.WriteString("  __typename?: 'Query';\n")
			case ast.Mutation:
				sb.WriteString("  __typename?: 'Mutation';\n")
			case ast.Subscription:
				sb.WriteString("  __typename?: 'Subscription';\n")
			}
		}

		p.generateSelectionSetTypes(sb, op.SelectionSet, s, strictNulls, immutableTypes, skipTypename, scalarMap, "  ")
		sb.WriteString("};\n\n")
	}
}

// generateSelectionSetTypes generates TypeScript types for a selection set
func (p *Plugin) generateSelectionSetTypes(sb *strings.Builder, selections ast.SelectionSet, s *ast.Schema, strictNulls bool, immutableTypes bool, skipTypename bool, scalarMap map[string]string, indent string) {
	// Group selections by response key
	type fieldInfo struct {
		field *ast.Field
		typ   *ast.Type
		def   *ast.FieldDefinition
	}
	fields := make(map[string]*fieldInfo)

	for _, sel := range selections {
		switch sel := sel.(type) {
		case *ast.Field:
			responseKey := sel.Alias
			if responseKey == "" {
				responseKey = sel.Name
			}

			// Track explicit __typename selections separately
			if sel.Name == "__typename" {
				fields[responseKey] = &fieldInfo{field: sel}
				continue
			}

			// Get field definition
			var parentDef *ast.Definition
			if sel.ObjectDefinition != nil {
				parentDef = sel.ObjectDefinition
			} else {
				// Try to find the parent type
				for _, def := range s.Types {
					for _, f := range def.Fields {
						if f.Name == sel.Name {
							parentDef = def
							break
						}
					}
					if parentDef != nil {
						break
					}
				}
			}

			if parentDef != nil {
				for _, f := range parentDef.Fields {
					if f.Name == sel.Name {
						fields[responseKey] = &fieldInfo{
							field: sel,
							typ:   f.Type,
							def:   f,
						}
						break
					}
				}
			}

		case *ast.InlineFragment:
			// Handle inline fragments
			p.generateSelectionSetTypes(sb, sel.SelectionSet, s, strictNulls, immutableTypes, skipTypename, scalarMap, indent)

		case *ast.FragmentSpread:
			// Fragment spreads are handled by including the fragment type
			sb.WriteString(fmt.Sprintf("%s// ...%s\n", indent, sel.Name))
		}
	}

	// Generate fields
	var fieldNames []string
	for name := range fields {
		fieldNames = append(fieldNames, name)
	}
	sort.Strings(fieldNames)

	for _, name := range fieldNames {
		info := fields[name]

		if info.def != nil && info.def.Description != "" {
			sb.WriteString(base.FormatComment(info.def.Description, indent))
		}

		if immutableTypes {
			sb.WriteString(indent + "readonly ")
		} else {
			sb.WriteString(indent)
		}

		if name == "__typename" {
			sb.WriteString(name + ": string;\n")
			continue
		}

		// Handle nested selections
		if len(info.field.SelectionSet) > 0 {
			// This field has sub-selections
			sb.WriteString(name + ": ")

			// Handle arrays
			isArray := info.typ != nil && info.typ.Elem != nil
			isNonNull := info.typ != nil && info.typ.NonNull

			if isArray {
				sb.WriteString("Array<{\n")
				hasNestedTypename := selectionHasExplicitTypename(info.field.SelectionSet)
				if !skipTypename && !hasNestedTypename && info.typ.Elem.NamedType != "" {
					// Try to get the type name for __typename
					if def, ok := s.Types[info.typ.Elem.NamedType]; ok && def.Kind == ast.Object {
						sb.WriteString(indent + "    __typename?: '" + def.Name + "';\n")
					}
				}
				p.generateSelectionSetTypes(sb, info.field.SelectionSet, s, strictNulls, immutableTypes, skipTypename, scalarMap, indent+"    ")
				sb.WriteString(indent + "  }>")
			} else {
				sb.WriteString("{\n")
				hasNestedTypename := selectionHasExplicitTypename(info.field.SelectionSet)
				if !skipTypename && !hasNestedTypename && info.typ != nil && info.typ.NamedType != "" {
					// Try to get the type name for __typename
					if def, ok := s.Types[info.typ.NamedType]; ok && def.Kind == ast.Object {
						sb.WriteString(indent + "    __typename?: '" + def.Name + "';\n")
					}
				}
				p.generateSelectionSetTypes(sb, info.field.SelectionSet, s, strictNulls, immutableTypes, skipTypename, scalarMap, indent+"    ")
				sb.WriteString(indent + "  }")
			}

			// Handle nullability
			if !isNonNull && strictNulls {
				sb.WriteString(" | null")
			}
			sb.WriteString(";\n")
		} else {
			// Simple field without sub-selections
			tsType := base.TypeToTypeScript(info.typ, scalarMap, strictNulls)
			sb.WriteString(name + ": " + tsType + ";\n")
		}
	}
}

func selectionHasExplicitTypename(selections ast.SelectionSet) bool {
	for _, sel := range selections {
		switch s := sel.(type) {
		case *ast.Field:
			if s.Name == "__typename" {
				return true
			}
		case *ast.InlineFragment:
			if selectionHasExplicitTypename(s.SelectionSet) {
				return true
			}
		}
	}
	return false
}
